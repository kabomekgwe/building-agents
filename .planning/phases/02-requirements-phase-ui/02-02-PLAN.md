---
phase: 02-requirements-phase-ui
plan: 02
type: execute
---

<objective>
Build Claude API integration for PRD generation and display interface with safe markdown rendering.

Purpose: Connect requirements form data to Claude API, generate professional PRD, and display it safely for user review. This completes the requirements phase workflow by transforming user inputs into a structured PRD document.

Output: Working PRD generation API endpoint, safe markdown display interface, and completed requirements phase workflow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase constraints from mapping:**
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/INTEGRATIONS.md

**Discovery findings:**
@.planning/phases/02-requirements-phase-ui/DISCOVERY.md

**Prior phase work:**
@.planning/phases/01-ui-foundation/01-01-SUMMARY.md
@.planning/phases/02-requirements-phase-ui/02-01-SUMMARY.md

**Technologies that must be used:**
- TypeScript 5.7.2 with strict mode
- Hono v4.6.14 web framework
- @anthropic-ai/sdk 0.32.1 (Claude API integration)
- Zod for input validation
- No external UI libraries (vanilla HTML/CSS/JS)

**Patterns that must be followed:**
- File naming: kebab-case.ts
- Function naming: camelCase
- Type naming: PascalCase
- API responses: `{ success: boolean, data?: T, error?: string }`
- 2 spaces indentation, no trailing semicolons
- Security-conscious DOM manipulation (createElement/textContent, not innerHTML)

**Prior decisions affecting this plan:**
- Claude API integration exists in src/runtime/executor.ts (reuse pattern)
- Model: claude-sonnet-4-20250514, max tokens 8192
- RequirementsFormData type defined in 02-01-PLAN.md
- Autosave saves to session.phaseData.requirements
- Safe DOM methods mandatory (no innerHTML)

**Discovery recommendations:**
- Use XML tags in prompt: <context>, <task>, <format>
- Temperature: 0.7 for balanced creativity
- System prompt: "You are an expert product manager writing professional PRDs"
- PRD structure: Overview, Purpose, Target Audience, Success Metrics, Features, Scope, Out of Scope, Timeline
- Allow user to review and regenerate if needed

**Existing Claude API integration pattern (from INTEGRATIONS.md):**
```typescript
// src/runtime/executor.ts example
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
})

const message = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  max_tokens: 8192,
  temperature: 0.7,
  system: 'System prompt here',
  messages: [{ role: 'user', content: 'Prompt here' }]
})
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PRD generation API endpoint with Claude integration</name>
  <files>src/api/server.ts, src/sdlc/types.ts</files>
  <action>
Implement Claude API integration to generate professional PRDs from requirements form data.

**Backend Changes:**

1. **Update RequirementsFormData type in src/sdlc/types.ts:**
```typescript
export interface RequirementsFormData {
  projectName: string;
  description: string;
  problemStatement: string;
  targetAudience: string;
  features: string[];
  successMetrics: string[];
  outOfScope: string[];
  lastSaved?: Date;
  generatedPRD?: string;  // Stores generated PRD markdown
  generatedAt?: Date;     // Timestamp of generation
}
```

2. **Add PRD generation API route in src/api/server.ts:**
```typescript
POST /api/planning/requirements/generate-prd

Input: None (reads from current planning session)

Logic:
- Get current planning session
- Validate session.phaseData.requirements exists and is complete
- Construct Claude API prompt using XML structure
- Call Claude API to generate PRD
- Store generated PRD in session.phaseData.requirements.generatedPRD
- Set session.phaseData.requirements.generatedAt = new Date()
- Return { success: true, data: { prd: generatedPRD, generatedAt: timestamp } }

Error handling:
- No active session: 404 "No planning session found"
- Requirements incomplete: 400 "Requirements form not completed"
- Claude API error: 500 with error message
```

3. **PRD Generation Function:**
```typescript
import Anthropic from '@anthropic-ai/sdk';

async function generatePRD(requirements: RequirementsFormData): Promise<string> {
  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });

  const prompt = buildPRDPrompt(requirements);

  try {
    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4000,  // PRDs typically 500-2000 tokens
      temperature: 0.7,  // Balanced creativity
      system: 'You are an expert product manager with 15 years of experience writing professional Product Requirements Documents (PRDs). You create clear, comprehensive PRDs that align with modern 2025 best practices.',
      messages: [{ role: 'user', content: prompt }]
    });

    // Extract text content from response
    const prdText = message.content
      .filter(block => block.type === 'text')
      .map(block => block.text)
      .join('\n');

    return prdText;
  } catch (error) {
    console.error('Claude API error:', error);
    throw new Error(`Failed to generate PRD: ${error.message}`);
  }
}

function buildPRDPrompt(requirements: RequirementsFormData): string {
  return `<context>
The user is planning a new project and has provided the following information:

**Project Name:** ${requirements.projectName}

**High-Level Description:**
${requirements.description}

**Problem Statement:**
${requirements.problemStatement}

**Target Audience:**
${requirements.targetAudience}

**Key Features:**
${requirements.features.map((f, i) => `${i + 1}. ${f}`).join('\n')}

**Success Metrics:**
${requirements.successMetrics.map((m, i) => `${i + 1}. ${m}`).join('\n')}

**Out of Scope:**
${requirements.outOfScope.length > 0
  ? requirements.outOfScope.map((item, i) => `${i + 1}. ${item}`).join('\n')
  : 'Not specified'}
</context>

<task>
Generate a professional Product Requirements Document (PRD) based on the information above.

Follow modern PRD best practices for 2025:
- Be concise but comprehensive
- Focus on shared understanding, not exhaustive detail
- Include clear rationale for decisions
- Make it a living document that can evolve

Include all standard sections:
1. Overview - High-level summary of what's being built and why
2. Purpose - Problem being solved and objectives
3. Target Audience - User personas and market segments
4. Success Metrics - KPIs and measurable outcomes
5. Features - Specific capabilities with user benefits
6. Scope - What's included in this release
7. Out of Scope - Explicitly stated non-goals
8. Timeline - Suggested milestones and release planning

Format as markdown with clear headings, bullet points, and logical structure.
</task>

<format>
# [Project Name] - Product Requirements Document

*Version 1.0 | Generated: [Current Date]*

## Overview
[2-3 paragraphs describing what's being built and the high-level vision]

## Purpose

### Problem Statement
[Detailed problem description]

### Objectives
- [Objective 1]
- [Objective 2]
- ...

## Target Audience

### User Personas
[Describe who will use this]

### Market Segments
[If applicable, define market positioning]

## Success Metrics
[List measurable outcomes and KPIs from user input]

## Features

### [Feature Category 1]
- **[Feature Name]**: [Description and user benefit]
- ...

### [Feature Category 2]
- **[Feature Name]**: [Description and user benefit]
- ...

## Scope

### In Scope
[What will be delivered in this release]

### Out of Scope
[Explicitly stated non-goals from user input]

## Timeline

### Suggested Milestones
- **Phase 1**: [Description] - [Timeframe]
- **Phase 2**: [Description] - [Timeframe]
- ...

### Release Planning
[Recommended release strategy]

---

*This PRD is a living document and should be reviewed and updated as the project evolves.*
</format>

If any information seems incomplete or unclear, make reasonable assumptions based on the context provided, but note them in the document.
`;
}
```

**Validation:**
- Ensure all required fields in RequirementsFormData are present
- Check that features and successMetrics arrays have at least 1 item
- Validate ANTHROPIC_API_KEY environment variable is set

**Error Response Examples:**
```typescript
// Missing requirements
{ success: false, error: "Requirements form must be completed before generating PRD" }

// API key missing
{ success: false, error: "Claude API key not configured" }

// Claude API error
{ success: false, error: "Failed to generate PRD: Rate limit exceeded" }
```

Reuse the existing Anthropic import pattern from src/runtime/executor.ts for consistency.
  </action>
  <verify>
- POST /api/planning/requirements/generate-prd returns 400 if requirements incomplete
- POST /api/planning/requirements/generate-prd calls Claude API with structured prompt
- Response includes generated PRD markdown in { success: true, data: { prd, generatedAt } }
- Generated PRD stored in session.phaseData.requirements.generatedPRD
- TypeScript compiles without errors
  </verify>
  <done>PRD generation API endpoint exists, integrates with Claude API, stores generated PRD in session, handles errors gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Build PRD display and review interface with safe markdown rendering</name>
  <files>src/api/server.ts</files>
  <action>
Add PRD display UI to the /planning route that safely renders markdown without using innerHTML.

**Frontend Changes (in /planning route's JavaScript):**

1. **Add "Generate PRD" button to Step 4 of requirements form:**
```javascript
// In Step 4 (Success & Scope), replace "Continue" button with "Generate PRD" button
const generateButton = document.createElement('button');
generateButton.textContent = 'Generate PRD';
generateButton.className = 'btn-primary';
generateButton.disabled = !validateStep(4); // Only enable if step valid

generateButton.addEventListener('click', async () => {
  generateButton.disabled = true;
  generateButton.textContent = 'Generating...';

  await generatePRD();
});
```

2. **PRD Generation Function:**
```javascript
async function generatePRD() {
  try {
    const response = await fetch('/api/planning/requirements/generate-prd', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });

    const result = await response.json();

    if (result.success) {
      displayPRD(result.data.prd);
    } else {
      showError(result.error);
    }
  } catch (error) {
    console.error('PRD generation failed:', error);
    showError('Failed to generate PRD. Please try again.');
  }
}
```

3. **Safe Markdown Rendering (NO innerHTML - uses createElement/textContent):**
```javascript
function displayPRD(prdMarkdown) {
  // Create PRD display container
  const container = document.querySelector('.phase-content');
  container.innerHTML = ''; // Safe to clear existing content

  const prdCard = document.createElement('div');
  prdCard.className = 'glass-card';

  const header = document.createElement('div');
  header.className = 'prd-header';

  const title = document.createElement('h2');
  title.textContent = 'Generated PRD';
  header.appendChild(title);

  const actions = document.createElement('div');
  actions.className = 'prd-actions';

  const regenerateBtn = document.createElement('button');
  regenerateBtn.textContent = 'Regenerate';
  regenerateBtn.className = 'btn-secondary';
  regenerateBtn.addEventListener('click', () => generatePRD());

  const downloadBtn = document.createElement('button');
  downloadBtn.textContent = 'Download PRD';
  downloadBtn.className = 'btn-secondary';
  downloadBtn.addEventListener('click', () => downloadPRD(prdMarkdown));

  const completeBtn = document.createElement('button');
  completeBtn.textContent = 'Complete Requirements Phase';
  completeBtn.className = 'btn-primary';
  completeBtn.addEventListener('click', () => completePhase());

  actions.appendChild(regenerateBtn);
  actions.appendChild(downloadBtn);
  actions.appendChild(completeBtn);
  header.appendChild(actions);

  prdCard.appendChild(header);

  // Render PRD markdown safely
  const contentDiv = document.createElement('div');
  contentDiv.className = 'prd-content';

  renderMarkdownSafely(prdMarkdown, contentDiv);

  prdCard.appendChild(contentDiv);
  container.appendChild(prdCard);
}

function renderMarkdownSafely(markdown, targetElement) {
  // Parse markdown line by line and build DOM safely
  const lines = markdown.split('\n');
  let currentList = null;
  let currentListType = null;

  lines.forEach(line => {
    const trimmed = line.trim();

    // Skip empty lines (but add spacing)
    if (!trimmed) {
      if (currentList) {
        targetElement.appendChild(currentList);
        currentList = null;
        currentListType = null;
      }
      const spacer = document.createElement('div');
      spacer.style.height = '0.5rem';
      targetElement.appendChild(spacer);
      return;
    }

    // Headers
    if (trimmed.startsWith('# ')) {
      const h1 = document.createElement('h1');
      h1.textContent = trimmed.substring(2);
      targetElement.appendChild(h1);
    } else if (trimmed.startsWith('## ')) {
      const h2 = document.createElement('h2');
      h2.textContent = trimmed.substring(3);
      targetElement.appendChild(h2);
    } else if (trimmed.startsWith('### ')) {
      const h3 = document.createElement('h3');
      h3.textContent = trimmed.substring(4);
      targetElement.appendChild(h3);
    }
    // Unordered list
    else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
      if (!currentList || currentListType !== 'ul') {
        if (currentList) targetElement.appendChild(currentList);
        currentList = document.createElement('ul');
        currentListType = 'ul';
      }
      const li = document.createElement('li');

      // Handle bold text within list items
      const text = trimmed.substring(2);
      parseInlineFormatting(text, li);

      currentList.appendChild(li);
    }
    // Ordered list
    else if (/^\d+\.\s/.test(trimmed)) {
      if (!currentList || currentListType !== 'ol') {
        if (currentList) targetElement.appendChild(currentList);
        currentList = document.createElement('ol');
        currentListType = 'ol';
      }
      const li = document.createElement('li');
      const text = trimmed.replace(/^\d+\.\s/, '');
      parseInlineFormatting(text, li);
      currentList.appendChild(li);
    }
    // Horizontal rule
    else if (trimmed === '---' || trimmed === '***') {
      const hr = document.createElement('hr');
      targetElement.appendChild(hr);
    }
    // Blockquote
    else if (trimmed.startsWith('> ')) {
      const blockquote = document.createElement('blockquote');
      blockquote.textContent = trimmed.substring(2);
      targetElement.appendChild(blockquote);
    }
    // Code block (inline)
    else if (trimmed.startsWith('`') && trimmed.endsWith('`')) {
      const code = document.createElement('code');
      code.textContent = trimmed.slice(1, -1);
      targetElement.appendChild(code);
    }
    // Italic (emphasis)
    else if (trimmed.startsWith('*') && trimmed.endsWith('*') && !trimmed.startsWith('**')) {
      const em = document.createElement('em');
      em.textContent = trimmed.slice(1, -1);
      targetElement.appendChild(em);
    }
    // Regular paragraph
    else {
      if (currentList) {
        targetElement.appendChild(currentList);
        currentList = null;
        currentListType = null;
      }
      const p = document.createElement('p');
      parseInlineFormatting(trimmed, p);
      targetElement.appendChild(p);
    }
  });

  // Append any remaining list
  if (currentList) {
    targetElement.appendChild(currentList);
  }
}

function parseInlineFormatting(text, targetElement) {
  // Handle bold (**text**), italic (*text*), and inline code (`code`)
  // Split by formatting markers while preserving them
  const parts = text.split(/(\*\*.*?\*\*|\*.*?\*|`.*?`)/g);

  parts.forEach(part => {
    if (!part) return;

    if (part.startsWith('**') && part.endsWith('**')) {
      const strong = document.createElement('strong');
      strong.textContent = part.slice(2, -2);
      targetElement.appendChild(strong);
    } else if (part.startsWith('*') && part.endsWith('*')) {
      const em = document.createElement('em');
      em.textContent = part.slice(1, -1);
      targetElement.appendChild(em);
    } else if (part.startsWith('`') && part.endsWith('`')) {
      const code = document.createElement('code');
      code.textContent = part.slice(1, -1);
      targetElement.appendChild(code);
    } else {
      targetElement.appendChild(document.createTextNode(part));
    }
  });
}
```

4. **Download PRD Function:**
```javascript
function downloadPRD(prdMarkdown) {
  const blob = new Blob([prdMarkdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `${requirementsFormData.projectName.replace(/\s+/g, '-')}-PRD.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

5. **Complete Phase Function:**
```javascript
async function completePhase() {
  try {
    const response = await fetch('/api/planning/phase/requirements/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        phaseData: {
          requirements: requirementsFormData
        }
      })
    });

    const result = await response.json();

    if (result.success) {
      // Reload planning page to show Design phase
      window.location.reload();
    } else {
      showError(result.error);
    }
  } catch (error) {
    console.error('Phase completion failed:', error);
    showError('Failed to complete phase. Please try again.');
  }
}
```

**CSS Styling (add to planning route's <style> tag):**
```css
.prd-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.prd-actions {
  display: flex;
  gap: 1rem;
}

.prd-content {
  max-width: 800px;
  line-height: 1.6;
}

.prd-content h1 {
  font-size: 2rem;
  margin-bottom: 1rem;
  color: #fff;
}

.prd-content h2 {
  font-size: 1.5rem;
  margin-top: 2rem;
  margin-bottom: 1rem;
  color: #e0e0e0;
}

.prd-content h3 {
  font-size: 1.25rem;
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  color: #d0d0d0;
}

.prd-content p {
  margin-bottom: 1rem;
  color: #c0c0c0;
}

.prd-content ul, .prd-content ol {
  margin-bottom: 1rem;
  padding-left: 2rem;
  color: #c0c0c0;
}

.prd-content li {
  margin-bottom: 0.5rem;
}

.prd-content strong {
  color: #fff;
  font-weight: 600;
}

.prd-content code {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.2rem 0.4rem;
  border-radius: 4px;
  font-family: 'Monaco', 'Courier New', monospace;
  font-size: 0.9em;
}

.prd-content hr {
  border: none;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  margin: 2rem 0;
}

.prd-content blockquote {
  border-left: 4px solid rgba(255, 255, 255, 0.3);
  padding-left: 1rem;
  margin: 1rem 0;
  font-style: italic;
  color: #b0b0b0;
}
```

**Security Notes:**
- Uses createElement and textContent exclusively - NO innerHTML
- Markdown parsing builds DOM programmatically
- User-generated content never executed as HTML
- Download function creates safe blob URLs

This approach maintains the security decision from Phase 1 while providing rich PRD display.
  </action>
  <verify>
- Click "Generate PRD" button on Step 4: PRD displays with formatted markdown
- PRD rendering shows headers, lists, bold text correctly
- No innerHTML usage anywhere in the code
- "Download PRD" button creates .md file with correct content
- "Regenerate" button calls API again and updates display
- No console errors or security warnings
  </verify>
  <done>PRD display interface exists with safe markdown rendering using createElement/textContent, includes download and regenerate functionality, no XSS vulnerabilities</done>
</task>

<task type="checkpoint">
  <name>Task 3: Verify PRD quality and phase completion workflow</name>
  <files>None (human verification)</files>
  <action>
**CHECKPOINT: Human Verification Required**

This checkpoint ensures the generated PRD meets quality standards and the requirements phase workflow completes correctly.

**What to Verify:**

1. **PRD Quality:**
   - Visit http://localhost:3000/planning
   - Complete all 4 steps of requirements form with realistic project data
   - Click "Generate PRD" button
   - Review generated PRD for:
     - All required sections present (Overview, Purpose, Target Audience, Success Metrics, Features, Scope, Out of Scope, Timeline)
     - Content is relevant to the form inputs provided
     - Professional tone and structure
     - No hallucinated information beyond reasonable inferences
     - Markdown formatting renders correctly (headings, lists, bold text)

2. **Regeneration:**
   - Click "Regenerate" button
   - Verify new PRD is generated (may be slightly different due to Claude's creativity)
   - Content should still be relevant and professional

3. **Download:**
   - Click "Download PRD" button
   - Verify .md file downloads with correct filename (e.g., "My-Project-PRD.md")
   - Open file in text editor - verify markdown content is complete and formatted

4. **Phase Completion:**
   - Click "Complete Requirements Phase" button
   - Verify page reloads and shows "Design" phase as current (Requirements marked complete)
   - Check /api/planning/state - verify currentPhase='design' and 'requirements' in completedPhases

5. **Error Handling:**
   - Try generating PRD with incomplete form (skip some required fields)
   - Verify appropriate error message shows
   - Try generating PRD without ANTHROPIC_API_KEY set (if testing error paths)
   - Verify graceful error handling

**Success Criteria:**
- ✅ PRD contains all required sections
- ✅ Content is relevant and professional
- ✅ Markdown renders correctly with safe DOM methods
- ✅ Download produces valid .md file
- ✅ Regenerate works correctly
- ✅ Phase completion advances workflow to Design phase
- ✅ No console errors or security warnings
- ✅ No innerHTML usage detected in DevTools

**If Issues Found:**
Document any problems with PRD quality, rendering issues, or workflow bugs. These will be addressed before finalizing the phase.

**Approval Decision:**
After verification, respond with:
- `approved` - All checks pass, proceed to summary
- `issues: [description]` - Problems found, need fixes
  </action>
  <verify>
Human verification of PRD quality and workflow completion
  </verify>
  <done>PRD quality verified, download works, phase completion advances workflow correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] `npm run dev` starts server without crashes
- [ ] POST /api/planning/requirements/generate-prd successfully calls Claude API
- [ ] Generated PRD stored in session.phaseData.requirements.generatedPRD
- [ ] PRD displays with safe markdown rendering (no innerHTML)
- [ ] All markdown elements render correctly (headers, lists, bold, italic, code)
- [ ] "Download PRD" creates valid .md file
- [ ] "Regenerate" button generates new PRD
- [ ] "Complete Requirements Phase" advances to Design phase
- [ ] No TypeScript errors or warnings
- [ ] No security warnings in browser console
- [ ] PRD quality meets professional standards (checkpoint verified)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Claude API integration generates professional PRDs
- Safe markdown rendering works without XSS vulnerabilities
- Requirements phase completes and advances to Design phase
- Download and regenerate functionality operational
- Checkpoint approval confirms PRD quality
- TypeScript strict mode passes
- No runtime errors in browser console
</success_criteria>

<output>
After completion, create `.planning/phases/02-requirements-phase-ui/02-02-SUMMARY.md`:

# Phase 2 Plan 2: Claude API PRD Generation Summary

**Claude API integration for PRD generation with safe markdown display - requirements phase complete.**

## Accomplishments

- Integrated Claude API for professional PRD generation
- Built safe markdown rendering without innerHTML usage
- Implemented download PRD functionality
- Added regenerate PRD capability
- Completed requirements phase workflow with Design phase transition
- Maintained security-first approach from Phase 1

## Files Created/Modified

- `src/api/server.ts` - Added PRD generation API endpoint and safe markdown display UI
- `src/sdlc/types.ts` - Extended RequirementsFormData with generatedPRD fields

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 2 complete - Ready for Phase 3: Design Phase UI (Technical spec and ADR creation interface)
</output>
