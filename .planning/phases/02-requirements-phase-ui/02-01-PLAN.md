---
phase: 02-requirements-phase-ui
plan: 01
type: execute
---

<objective>
Build multi-step requirements gathering form with progressive disclosure and validation.

Purpose: Create the UI foundation for collecting structured requirements inputs that will be sent to Claude API for PRD generation. This implements the frontend of the requirements phase workflow.

Output: Working requirements form at /planning with 4-step progressive disclosure, client-side validation, and autosave to planning session.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase constraints from mapping:**
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

**Discovery findings:**
@.planning/phases/02-requirements-phase-ui/DISCOVERY.md

**Prior phase work:**
@.planning/phases/01-ui-foundation/01-01-SUMMARY.md

**Technologies that must be used:**
- TypeScript 5.7.2 with strict mode
- Hono v4.6.14 web framework
- Existing glassmorphic UI patterns from public/index.html
- Zod for form validation schemas
- No external UI libraries (vanilla HTML/CSS/JS)

**Patterns that must be followed:**
- File naming: kebab-case.ts
- Function naming: camelCase
- Type naming: PascalCase
- API responses: `{ success: boolean, data?: T, error?: string }`
- 2 spaces indentation, no trailing semicolons
- Security-conscious DOM manipulation (createElement/textContent, not innerHTML)

**Prior decisions affecting this plan:**
- Reuse glassmorphic UI patterns from Phase 1 (visual consistency)
- In-memory Map storage for planning sessions (extends existing pattern)
- Hard gates enforce workflow discipline (users cannot skip requirements phase)
- Multi-step form with progressive disclosure (from discovery - don't overwhelm users)

**Discovery recommendations:**
- Use 4-step progressive disclosure: (1) Project Basics, (2) Problem & Solution, (3) Features & Capabilities, (4) Success & Scope
- Open-ended questions first, then specific details
- Real-time validation on blur (not every keystroke)
- Autosave state to session (resume if browser refreshes)
- Character count hints for textarea fields

**Existing planning session structure (from Phase 1):**
```typescript
interface PlanningSession {
  id: string;
  projectName: string;
  currentPhase: 'requirements' | 'design' | 'implementation';
  completedPhases: string[];
  phaseData: {
    requirements?: any;  // Will store form inputs here
    design?: any;
    implementation?: any;
  };
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-step requirements form structure</name>
  <files>src/api/server.ts</files>
  <action>
Extend the `/planning` route's HTML template to add requirements form UI when currentPhase='requirements'.

Add a new section within the phase content area that displays when Requirements phase is active:

**4-Step Form Structure:**
Step 1: Project Basics
- Field: Project Name (text input, pre-filled if session exists)
- Field: High-Level Description (textarea, 200 char min, placeholder: "Describe what you're building in 2-3 sentences")

Step 2: Problem & Solution
- Field: Problem Statement (textarea, 300 char min, placeholder: "What problem are you solving? Who is affected?")
- Field: Target Audience (textarea, placeholder: "Who will use this? Define your user personas")

Step 3: Features & Capabilities
- Field: Key Features (dynamic list, add/remove buttons, min 1 feature required)
- Each feature: text input with "+" button to add more, "×" button to remove
- Placeholder: "What specific capabilities will this provide?"

Step 4: Success & Scope
- Field: Success Metrics (dynamic list, min 1 metric required)
- Field: Out of Scope (dynamic list, optional)
- Placeholder for metrics: "How will you measure success? (e.g., 'Users can complete signup in <60 seconds')"
- Placeholder for out-of-scope: "What should we explicitly NOT build in this version?"

**UI Components:**
- Progress indicator showing "Step X of 4"
- "Back" button (disabled on Step 1)
- "Continue" button (disabled until required fields valid, changes to "Generate PRD" on Step 4)
- Each step slides in/out with simple CSS transition
- Reuse glassmorphic card styling from Phase 1
- Form fields use existing `.input-group` styles

**JavaScript State Management:**
- Track currentStep (1-4)
- Store all form values in memory object: `formData = { projectName, description, problemStatement, ... }`
- Show/hide steps based on currentStep
- Validate required fields before enabling "Continue"
- On "Back", save current step data and go to previous step
- On "Continue", save current step data and go to next step
- On "Generate PRD" (Step 4), prepare data for submission (handled in Task 3)

**Validation Display:**
- Character counters below textareas (e.g., "45 / 200 characters")
- Red border + error message on invalid fields
- Error messages: "Project name must be at least 3 characters", "Please add at least one feature", etc.
- Don't validate until user interacts with field (blur event)

Use safe DOM methods (createElement, textContent) - never innerHTML for user input.
  </action>
  <verify>
- Visit http://localhost:3000/planning after starting a session
- Requirements phase shows 4-step form interface
- All 4 steps can be navigated with Back/Continue buttons
- Character counters update as user types
- Required field validation prevents Continue until satisfied
- Form styling matches glassmorphic design from Phase 1
  </verify>
  <done>Multi-step form UI exists with 4 steps, validates required fields, displays character counts, uses glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 2: Implement form validation and state management</name>
  <files>src/api/server.ts</files>
  <action>
Add client-side JavaScript validation and form state management to the requirements form.

**Validation Rules (client-side):**
```javascript
const validationRules = {
  projectName: { min: 3, max: 100, required: true },
  description: { min: 50, max: 500, required: true },
  problemStatement: { min: 100, max: 1000, required: true },
  targetAudience: { min: 50, max: 500, required: true },
  features: { minItems: 1, maxItems: 20, required: true },
  successMetrics: { minItems: 1, maxItems: 10, required: true },
  outOfScope: { minItems: 0, maxItems: 10, required: false }
};
```

**Validation Functions:**
- `validateField(fieldName, value)` - Returns `{ valid: boolean, error?: string }`
- `validateStep(stepNumber)` - Validates all fields in current step
- `updateCharCount(textarea, counter)` - Updates character count display
- `showFieldError(field, message)` - Displays inline error message
- `clearFieldError(field)` - Removes error message

**Event Handlers:**
- On `blur` for text inputs/textareas: Validate field, show error if invalid
- On `input` for textareas: Update character counter
- On "Add Feature/Metric" button click: Add new input to list
- On "Remove" button click: Remove input from list (minimum 1 for required lists)
- On "Continue" button click: Validate current step, proceed if valid
- On "Back" button click: Save data, go to previous step (no validation)

**State Persistence:**
Store form data in global JavaScript object:
```javascript
let requirementsFormData = {
  projectName: '',
  description: '',
  problemStatement: '',
  targetAudience: '',
  features: [''],
  successMetrics: [''],
  outOfScope: []
};
```

Update this object as user types/changes fields. This will be sent to API in Task 3.

**Dynamic List Management (Features, Metrics, Out of Scope):**
- Render input fields from array in `requirementsFormData`
- "+" button: `requirementsFormData.features.push('')`, re-render list
- "×" button: `requirementsFormData.features.splice(index, 1)`, re-render list
- Don't allow removing last item if field is required (disable "×" button)

**UI Feedback:**
- Invalid field: Red border (`border: 2px solid #ef4444`)
- Valid field: No visual change (default state)
- Error message: Red text below field
- Character counter: Gray text when under limit, red when over limit
- "Continue" button: Disabled (opacity 0.5, cursor not-allowed) until step valid

No server calls yet - all validation is client-side. Server-side validation added in Plan 2.
  </action>
  <verify>
- Fill in Step 1 with invalid project name (< 3 chars): Continue button stays disabled
- Fill in valid project name: Continue button enables
- Navigate to Step 2, leave problem statement empty, try to continue: Error message shows
- Add 3 features, remove 2: Works correctly, cannot remove last feature
- Character counter turns red when exceeding limit
- All validation rules enforce correctly
  </verify>
  <done>Client-side validation works for all fields, dynamic lists support add/remove, character counters update, Continue button enables/disables based on validation</done>
</task>

<task type="auto">
  <name>Task 3: Add form autosave to planning session</name>
  <files>src/api/server.ts, src/sdlc/types.ts</files>
  <action>
Implement autosave functionality that stores requirements form data in the planning session.

**Backend Changes:**

1. **Update PlanningSession type in src/sdlc/types.ts:**
```typescript
export interface RequirementsFormData {
  projectName: string;
  description: string;
  problemStatement: string;
  targetAudience: string;
  features: string[];
  successMetrics: string[];
  outOfScope: string[];
  lastSaved?: Date;
}

// Update phaseData in PlanningSession:
phaseData: {
  requirements?: RequirementsFormData;
  design?: any;
  implementation?: any;
};
```

2. **Add autosave API route in src/api/server.ts:**
```typescript
POST /api/planning/requirements/autosave

Input schema (Zod):
const AutosaveRequirementsSchema = z.object({
  projectName: z.string().min(3).max(100),
  description: z.string().min(50).max(500),
  problemStatement: z.string().min(100).max(1000),
  targetAudience: z.string().min(50).max(500),
  features: z.array(z.string()).min(1).max(20),
  successMetrics: z.array(z.string()).min(1).max(10),
  outOfScope: z.array(z.string()).max(10).optional().default([])
});

Logic:
- Get current planning session (same pattern as /api/planning/state)
- Validate input with Zod schema
- Update session.phaseData.requirements with form data
- Set session.phaseData.requirements.lastSaved = new Date()
- Return { success: true, data: { lastSaved: timestamp } }
```

**Frontend Changes (in /planning route's JavaScript):**

Add autosave functionality:
```javascript
// Autosave every 30 seconds if form has changes
let autosaveTimer;
let formDirty = false;

function markFormDirty() {
  formDirty = true;
  if (!autosaveTimer) {
    autosaveTimer = setTimeout(autosave, 30000); // 30 seconds
  }
}

async function autosave() {
  if (!formDirty) return;

  try {
    const response = await fetch('/api/planning/requirements/autosave', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requirementsFormData)
    });

    const result = await response.json();
    if (result.success) {
      formDirty = false;
      showAutosaveIndicator('Saved');
    }
  } catch (error) {
    console.error('Autosave failed:', error);
  }

  autosaveTimer = null;
}

function showAutosaveIndicator(message) {
  // Display "Saved ✓" message briefly in UI (top-right corner)
  // Fade out after 2 seconds
}

// Attach markFormDirty to all input events
document.querySelectorAll('input, textarea').forEach(el => {
  el.addEventListener('input', markFormDirty);
});
```

**Load saved data on page load:**
```javascript
async function loadSavedRequirements() {
  const state = await fetch('/api/planning/state').then(r => r.json());
  if (state.success && state.data.phaseData?.requirements) {
    requirementsFormData = state.data.phaseData.requirements;
    populateFormFromData();
  }
}

// Call on page load
loadSavedRequirements();
```

**Autosave Trigger Events:**
- User types in any field (debounced to 30 seconds)
- User clicks "Back" or "Continue" (immediate save before navigation)
- User leaves page (beforeunload event - best effort)

**UI Indicator:**
- Small "Saving..." or "Saved ✓" message in top-right corner
- Fades out after 2 seconds
- Only show after successful autosave

This ensures users never lose their work even if they refresh the browser or close the tab.
  </action>
  <verify>
- Fill in Step 1, wait 30 seconds: Autosave indicator shows "Saved ✓"
- Refresh browser: Form data persists, pre-fills from saved state
- Fill in Steps 1-3, close browser, reopen: All data still present
- Check /api/planning/state: phaseData.requirements contains form inputs
- TypeScript compiles without errors
  </verify>
  <done>Autosave API route exists, client-side autosave triggers every 30 seconds, saved data persists across page refreshes, UI shows save indicator</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] `npm run dev` starts server without crashes
- [ ] Visit /planning with requirements phase active
- [ ] 4-step form displays with all fields
- [ ] Form validation prevents Continue until required fields valid
- [ ] Dynamic lists (features, metrics) support add/remove
- [ ] Character counters update in real-time
- [ ] Autosave triggers after 30 seconds of inactivity
- [ ] Refreshing browser preserves form data
- [ ] No TypeScript errors or warnings
- [ ] UI matches glassmorphic aesthetic from Phase 1
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Multi-step requirements form operational at /planning
- Form validation works client-side with visual feedback
- Autosave preserves user input across sessions
- Character counters and dynamic lists function correctly
- Styling consistent with existing dashboard
- TypeScript strict mode passes
- No runtime errors in browser console
</success_criteria>

<output>
After completion, create `.planning/phases/02-requirements-phase-ui/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Requirements Form UI Summary

**Multi-step requirements gathering form with validation and autosave - ready for Claude integration.**

## Accomplishments

- Created 4-step progressive disclosure requirements form
- Implemented client-side validation with visual feedback
- Added autosave functionality preserving user inputs
- Built dynamic list UI for features/metrics/out-of-scope
- Integrated character counters for textarea fields
- Extended planning session types for requirements data

## Files Created/Modified

- `src/api/server.ts` - Added requirements form HTML template and autosave API route
- `src/sdlc/types.ts` - Added RequirementsFormData interface

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 02-02-PLAN.md - Claude API integration and PRD generation
</output>
