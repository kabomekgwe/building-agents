---
phase: 03-design-phase-ui
plan: 02
type: execute
---

<objective>
Integrate Claude API to generate Technical Specifications and Architecture Decision Records (ADRs).

Purpose: Implement backend API endpoints that use Claude to generate professional technical documentation from design form inputs. This completes the design phase workflow by transforming structured inputs into markdown documents.

Output: Working Tech Spec generation + individual ADR generation with safe markdown rendering and download capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase constraints:**
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

**Discovery findings:**
@.planning/phases/03-design-phase-ui/DISCOVERY.md

**Prior phase work:**
@.planning/phases/02-requirements-phase-ui/02-02-SUMMARY.md (Claude API integration pattern)
@.planning/phases/03-design-phase-ui/03-01-PLAN.md (Design form UI just completed)

**Technologies that must be used:**
- @anthropic-ai/sdk v0.32.1 (existing integration)
- Claude model: claude-sonnet-4-20250514 (same as Phase 2)
- Zod for API input validation
- Safe DOM methods (createElement/textContent) for markdown rendering

**Patterns that must be followed:**
- Reuse Claude API integration pattern from Phase 2 (02-02-SUMMARY.md)
- XML-structured prompts with `<context>`, `<task>`, `<format>` tags
- Safe markdown rendering using createElement/textContent (NO innerHTML)
- DesignFormData type from 03-01-PLAN.md
- API responses: `{ success: boolean, data?: T, error?: string }`

**Prior decisions affecting this plan:**
- XML-structured prompts for Claude API (proven in Phase 2)
- Line-by-line markdown parsing with createElement/textContent (security-conscious)
- claude-sonnet-4-20250514 model (consistency with existing integration)
- Generate separate ADRs (one file per architectural decision)
- Tech Spec max tokens: 6000, ADRs: 2000 each (from discovery)
- Sequential generation: Tech Spec first, then ADRs individually

**Discovery recommendations:**
- Follow Michael Nygard ADR template (Title, Status, Context, Decision, Consequences)
- Tech Spec sections: Overview, System Architecture, Component Breakdown, Data Models, Technology Stack, Non-Functional Requirements, API Specifications, Dependencies, Deployment Strategy, Testing Strategy
- Include PRD context from Phase 2 in Tech Spec generation prompt
- Each ADR gets unique ID (ADR-001, ADR-002, etc.)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend types and add Tech Spec generation endpoint</name>
  <files>src/sdlc/types.ts, src/api/server.ts</files>
  <action>
Extend DesignFormData type and implement Technical Specification generation.

**1. Update src/sdlc/types.ts:**
```typescript
export interface GeneratedADR {
  id: string; // ADR-001, ADR-002, etc.
  title: string;
  content: string; // Full markdown content
  generatedAt: Date;
}

// Extend DesignFormData interface (add to existing definition):
export interface DesignFormData {
  // ... existing fields from 03-01-PLAN.md ...
  generatedTechSpec?: string;  // ADD: Claude-generated Tech Spec
  techSpecGeneratedAt?: Date;   // ADD: Timestamp
  generatedADRs?: GeneratedADR[];  // ADD: Claude-generated ADRs
}
```

**2. Add Tech Spec generation function in src/api/server.ts:**
```typescript
async function generateTechSpec(
  designData: DesignFormData,
  prdContext?: string
): Promise<string> {
  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });

  const prompt = buildTechSpecPrompt(designData, prdContext);

  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 6000, // Larger than PRD for comprehensive tech spec
    temperature: 0.7,
    system: 'You are an expert software architect writing professional technical specifications. Generate comprehensive, maintainable documentation following modern software engineering best practices.',
    messages: [{
      role: 'user',
      content: prompt
    }]
  });

  const textContent = message.content.filter(block => block.type === 'text');
  return textContent.map(block => block.text).join('\n');
}

function buildTechSpecPrompt(
  designData: DesignFormData,
  prdContext?: string
): string {
  return `<context>
Project: ${designData.systemArchitecture} architecture

Previous Context (PRD from Requirements Phase):
${prdContext || 'No PRD available'}

Design Inputs:
- System Architecture: ${designData.systemArchitecture}
- Architecture Description: ${designData.architectureDescription}
- Components: ${JSON.stringify(designData.components, null, 2)}
- Database Schema: ${designData.databaseSchema}
- API Contracts: ${designData.apiContracts}
- Technology Stack:
  Languages: ${designData.technologyStack.languages.join(', ')}
  Frameworks: ${designData.technologyStack.frameworks.join(', ')}
  Databases: ${designData.technologyStack.databases.join(', ')}
  Infrastructure: ${designData.technologyStack.infrastructure.join(', ')}
- Architectural Decisions: ${designData.architecturalDecisions.length} key decisions defined
</context>

<task>
Generate a professional Technical Specification Document based on the design inputs above.

Follow modern software engineering best practices for 2025 - be comprehensive but maintainable.

Include all standard sections:
1. Overview - High-level system description
2. System Architecture - Architectural pattern, component diagram (ASCII art or description)
3. Component Breakdown - Key modules/services and their responsibilities
4. Data Models - Database schema, API contracts, data structures
5. Technology Stack - Languages, frameworks, infrastructure choices with rationale
6. Non-Functional Requirements - Performance, security, scalability, availability targets
7. API Specifications - Key endpoints, request/response formats
8. Dependencies - External services, libraries, integrations
9. Deployment Strategy - How the system will be deployed and operated
10. Testing Strategy - Unit, integration, E2E testing approach

Format as markdown with clear headings, bullet points, and code blocks for schemas.
Use ## for section headings (not #, as # is reserved for document title).
</task>

<format>
# Technical Specification: [Project Name]

## Overview
[2-3 paragraphs describing the system at a high level]

## System Architecture
[Describe the architectural pattern and key design decisions]

[Continue with all sections...]
</format>

Ask for any clarifications needed to generate the highest quality Technical Specification.`;
}
```

**3. Add Tech Spec generation API endpoint:**
```typescript
POST /api/planning/design/generate-techspec

Handler logic:
- Get current planning session
- Verify currentPhase === 'design'
- Verify session.phaseData.design exists
- Get PRD context from session.phaseData.requirements?.generatedPRD
- Call generateTechSpec(session.phaseData.design, prdContext)
- Update session.phaseData.design.generatedTechSpec with result
- Update session.phaseData.design.techSpecGeneratedAt = new Date()
- Return { success: true, data: { techSpec: result, generatedAt: timestamp } }

Error handling:
- Return 400 if not in design phase
- Return 400 if design data missing
- Return 500 if Claude API call fails
- Log errors with context
```

Reuse the exact Anthropic SDK integration pattern from Phase 2's generatePRD() function.
  </action>
  <verify>
- POST /api/planning/design/generate-techspec returns success
- Response contains generatedTechSpec and techSpecGeneratedAt
- Tech Spec is formatted as markdown with all required sections
- Tech Spec includes PRD context from Phase 2 in Overview section
- Tech Spec references components, tech stack from design form
- TypeScript compiles without errors
- No API key exposure in responses
  </verify>
  <done>Tech Spec generation function exists, API endpoint works, generated output includes all required sections, integrates PRD context</done>
</task>

<task type="auto">
  <name>Task 2: Add ADR generation endpoint and frontend display</name>
  <files>src/api/server.ts</files>
  <action>
Implement individual ADR generation following Michael Nygard template.

**1. Add ADR generation function in src/api/server.ts:**
```typescript
async function generateADR(
  decision: ArchitecturalDecision,
  adrId: string,
  projectContext: string
): Promise<string> {
  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });

  const prompt = buildADRPrompt(decision, adrId, projectContext);

  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 2000, // Smaller than Tech Spec - ADRs are concise
    temperature: 0.7,
    system: 'You are an expert software architect writing Architecture Decision Records (ADRs) following the Michael Nygard template. Generate clear, concise ADRs that document architectural decisions with context and consequences.',
    messages: [{
      role: 'user',
      content: prompt
    }]
  });

  const textContent = message.content.filter(block => block.type === 'text');
  return textContent.map(block => block.text).join('\n');
}

function buildADRPrompt(
  decision: ArchitecturalDecision,
  adrId: string,
  projectContext: string
): string {
  return `<context>
${projectContext}

Architectural Decision to Document:
- Title: ${decision.title}
- Context Description: ${decision.contextDescription}
- Decision Made: ${decision.decisionMade}
- Rationale: ${decision.rationale}
</context>

<task>
Generate an Architecture Decision Record (ADR) following the Michael Nygard template.

The ADR must include these sections:
1. Title - ${decision.title}
2. Status - "proposed" (default for new ADRs)
3. Context - Describe the forces at play (technological, political, social, project-local). Be value-neutral. Call out tensions explicitly.
4. Decision - State our response to these forces in full sentences, active voice (e.g., "We will use...").
5. Consequences - Describe the resulting context after applying this decision. Include both positive and negative consequences.

Format as markdown.
Use ## for section headings (not #, as # is reserved for the ADR title).
</task>

<format>
# ${adrId}: ${decision.title}

**Status:** proposed

## Context
[Describe the forces at play, tensions, and facts. Value-neutral language.]

## Decision
[State the decision in full sentences, active voice. Be specific.]

## Consequences
[Describe the resulting context - both positive and negative outcomes.]
</format>`;
}
```

**2. Add ADR generation API endpoint:**
```typescript
POST /api/planning/design/generate-adr

Input schema:
const GenerateADRRequestSchema = z.object({
  decisionIndex: z.number().min(0) // Index in architecturalDecisions array
});

Handler logic:
- Get current planning session
- Verify currentPhase === 'design'
- Verify session.phaseData.design exists
- Get decision at decisionIndex from session.phaseData.design.architecturalDecisions
- Generate ADR ID: "ADR-" + (generatedADRs.length + 1).toString().padStart(3, '0')
  - Example: ADR-001, ADR-002, ADR-003
- Build project context from Tech Spec + design data
- Call generateADR(decision, adrId, projectContext)
- Create GeneratedADR object: { id: adrId, title: decision.title, content: result, generatedAt: new Date() }
- Append to session.phaseData.design.generatedADRs (initialize if undefined)
- Return { success: true, data: { adr: generatedADR } }

Error handling:
- Return 400 if not in design phase
- Return 400 if design data missing
- Return 400 if decisionIndex out of bounds
- Return 500 if Claude API call fails
```

**3. Add frontend display for Tech Spec and ADRs:**

Extend the `/planning` route's JavaScript to handle Tech Spec + ADR generation and display.

**Display Functions:**
```javascript
function displayTechSpec(techSpec) {
  // Reuse same safe markdown rendering from Phase 2
  // renderMarkdownSafely(techSpec, targetElement)
  // Same implementation as PRD display (createElement/textContent)
  const techSpecContainer = document.getElementById('tech-spec-display');
  techSpecContainer.style.display = 'block';

  const content = document.getElementById('tech-spec-content');
  renderMarkdownSafely(techSpec, content);

  // Add download button
  const downloadBtn = document.getElementById('download-tech-spec');
  downloadBtn.onclick = () => downloadTechSpec(techSpec);

  // Add "Generate ADRs" button (shows ADR generation UI)
  const generateADRsBtn = document.getElementById('generate-adrs-btn');
  generateADRsBtn.onclick = () => showADRGenerationUI();
}

function showADRGenerationUI() {
  // Display list of architectural decisions with "Generate ADR" button for each
  const adrUI = document.getElementById('adr-generation-ui');
  adrUI.style.display = 'block';

  const decisionsList = document.getElementById('decisions-list');
  // Clear existing
  while (decisionsList.firstChild) {
    decisionsList.removeChild(decisionsList.firstChild);
  }

  // Render each decision with generate button
  designFormData.architecturalDecisions.forEach((decision, index) => {
    const decisionCard = document.createElement('div');
    decisionCard.className = 'decision-card';

    const title = document.createElement('h4');
    title.textContent = decision.title;
    decisionCard.appendChild(title);

    const generateBtn = document.createElement('button');
    generateBtn.textContent = 'Generate ADR';
    generateBtn.onclick = () => generateIndividualADR(index);
    decisionCard.appendChild(generateBtn);

    decisionsList.appendChild(decisionCard);
  });
}

async function generateIndividualADR(decisionIndex) {
  // Show loading state
  const btn = event.target;
  btn.disabled = true;
  btn.textContent = 'Generating...';

  try {
    const response = await fetch('/api/planning/design/generate-adr', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ decisionIndex })
    });

    const result = await response.json();
    if (result.success) {
      displayADR(result.data.adr);
      btn.textContent = 'Regenerate ADR';
    }
  } catch (error) {
    console.error('ADR generation failed:', error);
    btn.textContent = 'Generate ADR (retry)';
  } finally {
    btn.disabled = false;
  }
}

function displayADR(adr) {
  // Render ADR in dedicated section
  const adrDisplay = document.getElementById('adr-display-' + adr.id);
  if (!adrDisplay) {
    // Create new ADR display card
    const adrCard = document.createElement('div');
    adrCard.className = 'adr-card';
    adrCard.id = 'adr-display-' + adr.id;

    const adrTitle = document.createElement('h3');
    adrTitle.textContent = adr.id + ': ' + adr.title;
    adrCard.appendChild(adrTitle);

    const adrContent = document.createElement('div');
    adrContent.className = 'adr-content';
    renderMarkdownSafely(adr.content, adrContent);
    adrCard.appendChild(adrContent);

    const downloadBtn = document.createElement('button');
    downloadBtn.textContent = 'Download ' + adr.id;
    downloadBtn.onclick = () => downloadADR(adr);
    adrCard.appendChild(downloadBtn);

    document.getElementById('adrs-container').appendChild(adrCard);
  }
}

function downloadTechSpec(techSpec) {
  const blob = new Blob([techSpec], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'technical-specification.md';
  a.click();
  URL.revokeObjectURL(url);
}

function downloadADR(adr) {
  const blob = new Blob([adr.content], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${adr.id}-${adr.title.toLowerCase().replace(/\s+/g, '-')}.md`;
  a.click();
  URL.revokeObjectURL(url);
}

function downloadAllADRs() {
  // Download all ADRs as separate files
  const adrs = designFormData.generatedADRs || [];
  adrs.forEach(adr => downloadADR(adr));
}
```

**Button Handlers:**
- "Generate Tech Spec & ADRs" button (Step 6) calls: `handleGenerateTechSpec()`
- `handleGenerateTechSpec()` calls POST /api/planning/design/generate-techspec
- On success, displays Tech Spec and shows ADR generation UI
- User clicks "Generate ADR" for each decision
- Each ADR displays in separate card with download button

**CSS Styling:**
Reuse glassmorphic card styling for Tech Spec and ADR displays. Add specific styles:
- `.tech-spec-display` - Container for Tech Spec
- `.adr-card` - Individual ADR card
- `.adr-content` - ADR markdown content area
- `.decision-card` - Decision card with generate button

Use safe DOM methods (createElement/textContent) for all markdown rendering.
  </action>
  <verify>
- Click "Generate Tech Spec & ADRs" button: Tech Spec generates and displays
- Tech Spec displays in glassmorphic card with download button
- ADR generation UI shows list of architectural decisions
- Click "Generate ADR" for decision 1: ADR-001 generates and displays
- ADR displays in separate card with markdown formatting
- Download Tech Spec button works, downloads .md file
- Download ADR button works, downloads ADR-001-[title].md file
- Generate multiple ADRs: IDs increment (ADR-001, ADR-002, ADR-003)
- Regenerate ADR: Replaces existing ADR content
- All markdown rendering uses createElement/textContent (no innerHTML)
  </verify>
  <done>Tech Spec generation works with display and download, ADR generation works for each decision individually, markdown rendering is safe, download functionality exists for all documents</done>
</task>

<task type="human-verify">
  <name>Task 3: Verify generated documentation quality</name>
  <action>
Manual verification checkpoint for generated documentation quality.

**Verify Tech Spec Quality:**
1. Start server, navigate to /planning
2. Complete design form (all 6 steps) with realistic project data
3. Click "Generate Tech Spec & ADRs"
4. Review generated Technical Specification:
   - [ ] Includes all required sections (Overview, System Architecture, Component Breakdown, Data Models, Technology Stack, Non-Functional Requirements, API Specifications, Dependencies, Deployment Strategy, Testing Strategy)
   - [ ] References PRD context from Phase 2
   - [ ] Mentions components, tech stack from design form
   - [ ] Uses proper markdown formatting (## headings, bullet points, code blocks)
   - [ ] Content is professional and comprehensive
   - [ ] No hallucinated information (all data comes from form inputs)

**Verify ADR Quality (test with 2-3 decisions):**
1. Click "Generate ADR" for first architectural decision
2. Review generated ADR-001:
   - [ ] Follows Michael Nygard template (Title, Status, Context, Decision, Consequences)
   - [ ] Status is "proposed" (default for new ADRs)
   - [ ] Context section describes forces at play with value-neutral language
   - [ ] Decision section uses active voice ("We will...")
   - [ ] Consequences section includes both positive and negative outcomes
   - [ ] Content matches the decision inputs from form
   - [ ] Markdown formatting is correct
3. Generate ADR-002 for second decision:
   - [ ] ADR ID increments correctly
   - [ ] Content is different from ADR-001
4. Download both ADRs:
   - [ ] Files download with correct names (ADR-001-[title].md, ADR-002-[title].md)
   - [ ] File contents match displayed content

**Verify UI/UX:**
- [ ] Loading states show during generation ("Generating Tech Spec...")
- [ ] Generated documents display in glassmorphic cards
- [ ] Download buttons work for Tech Spec and all ADRs
- [ ] "Regenerate" button allows updating generated content
- [ ] Markdown rendering displays headers, lists, code blocks correctly
- [ ] No JavaScript errors in browser console
- [ ] Safe DOM methods used (no innerHTML vulnerabilities)

If any quality issues found, iterate on prompts (buildTechSpecPrompt, buildADRPrompt) until output meets professional standards.
  </action>
  <verify>
All verification checks pass for Tech Spec quality, ADR quality, and UI/UX functionality.
  </verify>
  <done>Manual verification complete - Tech Spec and ADRs meet professional quality standards, UI works correctly, no security issues</done>
</task>

<task type="auto">
  <name>Task 4: Add phase completion workflow</name>
  <files>src/api/server.ts</files>
  <action>
Implement "Complete Design Phase" functionality that advances to implementation phase.

**Add phase completion button to frontend:**
After Tech Spec and all ADRs are generated, show "Complete Design Phase" button.

```javascript
function showCompletePhaseButton() {
  const completeBtn = document.getElementById('complete-design-phase-btn');
  completeBtn.style.display = 'block';
  completeBtn.onclick = completeDesignPhase;
}

async function completeDesignPhase() {
  const btn = event.target;
  btn.disabled = true;
  btn.textContent = 'Completing...';

  try {
    const response = await fetch('/api/planning/design/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });

    const result = await response.json();
    if (result.success) {
      // Reload page to show implementation phase
      window.location.reload();
    }
  } catch (error) {
    console.error('Phase completion failed:', error);
    btn.disabled = false;
    btn.textContent = 'Complete Design Phase';
  }
}
```

**Add backend endpoint:**
```typescript
POST /api/planning/design/complete

Handler logic:
- Get current planning session
- Verify currentPhase === 'design'
- Verify session.phaseData.design.generatedTechSpec exists
- Verify session.phaseData.design.generatedADRs has at least 1 ADR
- Update session.currentPhase = 'implementation'
- Add 'design' to session.completedPhases array
- Return { success: true, data: { currentPhase: 'implementation' } }

Error handling:
- Return 400 if not in design phase
- Return 400 if Tech Spec not generated
- Return 400 if no ADRs generated
- Return 400 if phase already completed
```

**Button Visibility Logic:**
Show "Complete Design Phase" button only when:
- Tech Spec is generated (session.phaseData.design.generatedTechSpec exists)
- At least 1 ADR is generated (session.phaseData.design.generatedADRs.length > 0)

Display completion requirements if not met:
"To complete Design Phase, you must:
- ✓ Generate Technical Specification
- ✗ Generate at least one Architecture Decision Record"
  </action>
  <verify>
- Generate Tech Spec and at least 1 ADR
- "Complete Design Phase" button appears
- Click button: Session advances to implementation phase
- Refresh page: Planning UI shows implementation phase (placeholder)
- Check /api/planning/state: currentPhase === 'implementation', completedPhases includes 'design'
- Try to complete phase without Tech Spec: Error message shown
- Try to complete phase without ADRs: Error message shown
  </verify>
  <done>Phase completion workflow exists, validates requirements, advances to implementation phase, provides clear feedback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] `npm run dev` starts server without crashes
- [ ] Complete design form (all 6 steps)
- [ ] Click "Generate Tech Spec & ADRs": Tech Spec generates successfully
- [ ] Tech Spec includes all required sections and PRD context
- [ ] Click "Generate ADR" for each decision: ADRs generate successfully
- [ ] ADRs follow Michael Nygard template (Title, Status, Context, Decision, Consequences)
- [ ] Download Tech Spec: File downloads correctly
- [ ] Download ADRs: Files download with correct names
- [ ] Click "Complete Design Phase": Session advances to implementation
- [ ] All markdown rendering uses createElement/textContent (no innerHTML)
- [ ] No API key exposure in responses or errors
- [ ] No TypeScript errors or warnings
- [ ] No runtime errors in browser console
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Tech Spec generation works with Claude API integration
- ADR generation works for individual architectural decisions
- Generated documents meet professional quality standards
- Safe markdown rendering prevents XSS vulnerabilities
- Download functionality works for all documents
- Phase completion workflow validates requirements and advances
- Styling consistent with existing dashboard
- TypeScript strict mode passes
- No security vulnerabilities (API keys, XSS)
</success_criteria>

<output>
After completion, create `.planning/phases/03-design-phase-ui/03-02-SUMMARY.md`:

# Phase 3 Plan 2: Claude API Tech Spec & ADR Generation Summary

**Claude API integration generating professional Technical Specifications and Architecture Decision Records via Nygard template**

## Performance

- **Duration:** [TBD]
- **Started:** [TBD]
- **Completed:** [TBD]
- **Tasks:** 4 (3 auto + 1 checkpoint)
- **Files modified:** 2

## Accomplishments

- Integrated Claude API for Technical Specification generation
- Built XML-structured prompt template including PRD context from Phase 2
- Implemented individual ADR generation following Michael Nygard template
- Created safe markdown rendering using createElement/textContent (NO innerHTML)
- Added download functionality for Tech Spec and all ADRs
- Implemented phase completion workflow with validation
- Generated ADR IDs increment correctly (ADR-001, ADR-002, etc.)
- Verified documentation quality meets professional standards (checkpoint approved)

## Files Created/Modified

**Modified:**
- `src/sdlc/types.ts` - Extended DesignFormData with generatedTechSpec, generatedADRs
- `src/api/server.ts` - Added Claude API integration (~600 lines)
  - Backend: generateTechSpec(), generateADR(), buildTechSpecPrompt(), buildADRPrompt()
  - API routes: POST /api/planning/design/generate-techspec, POST /api/planning/design/generate-adr, POST /api/planning/design/complete
  - Frontend: displayTechSpec(), showADRGenerationUI(), generateIndividualADR(), displayADR(), downloadTechSpec(), downloadADR(), completeDesignPhase()
  - CSS: Glassmorphic styling for Tech Spec and ADR displays

## Decisions Made

**Used claude-sonnet-4-20250514 model**
- Rationale: Matches existing integration for consistency with Phase 2
- Configuration: Tech Spec max_tokens 6000, ADRs max_tokens 2000, temperature 0.7

**Separate ADR generation (one API call per decision)**
- Rationale: Allows user control over which ADRs to generate, supports regeneration
- Better UX than batch generation (progress visibility)

**Michael Nygard ADR template**
- Rationale: Industry standard since 2011, simple 5-section format
- Discovery research confirmed wide adoption and recognition

**Sequential generation (Tech Spec first, then ADRs)**
- Rationale: Tech Spec provides context for ADR generation
- Follows natural workflow: design → document → decide

**Line-by-line markdown parsing with createElement/textContent**
- Rationale: Maintains Phase 2 security decision, prevents XSS
- Reuses renderMarkdownSafely() function from PRD display

## Deviations from Plan

None - plan executed exactly as written with no architectural changes or blocking issues.

## Issues Encountered

None - Implementation proceeded smoothly:
- Anthropic SDK integration reused existing pattern from Phase 2
- Safe markdown rendering handled all Tech Spec and ADR formatting
- TypeScript strict mode passed with zero compilation errors
- All checkpoint verification criteria met on first attempt

## Next Phase Readiness

**Design Phase Complete:**
- ✅ Multi-step design form operational (Plan 03-01)
- ✅ Client-side validation with autosave (Plan 03-01)
- ✅ Claude API Tech Spec generation working (Plan 03-02)
- ✅ Claude API ADR generation working (Plan 03-02)
- ✅ Safe markdown display with download capability (Plan 03-02)
- ✅ Phase completion workflow advances to Implementation phase (Plan 03-02)

**Ready for Phase 4: File Generation & Export**
- Generate markdown files with frontmatter compatible with Claude Code CLI
- Export Tech Spec, ADRs, PRD as .md files to disk
- Leverage DesignFormData.generatedTechSpec and generatedADRs

**No blockers or concerns**

---
*Phase: 03-design-phase-ui*
*Completed: [TBD]*
</output>
