---
phase: 03-design-phase-ui
plan: 01
type: execute
---

<objective>
Build multi-step design form with component breakdown and architectural decision inputs.

Purpose: Create the UI foundation for collecting structured design inputs that will be sent to Claude API for Technical Specification and ADR generation. This implements the frontend of the design phase workflow.

Output: Working design form at /planning with 6-step progressive disclosure, client-side validation, and autosave to planning session.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Codebase constraints from mapping:**
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md

**Discovery findings:**
@.planning/phases/03-design-phase-ui/DISCOVERY.md

**Prior phase work:**
@.planning/phases/01-ui-foundation/01-01-SUMMARY.md
@.planning/phases/02-requirements-phase-ui/02-01-SUMMARY.md
@.planning/phases/02-requirements-phase-ui/02-02-SUMMARY.md

**Technologies that must be used:**
- TypeScript 5.7.2 with strict mode
- Hono v4.6.14 web framework
- Existing glassmorphic UI patterns from public/index.html
- Zod for form validation schemas
- No external UI libraries (vanilla HTML/CSS/JS)

**Patterns that must be followed:**
- File naming: kebab-case.ts
- Function naming: camelCase
- Type naming: PascalCase
- API responses: `{ success: boolean, data?: T, error?: string }`
- 2 spaces indentation, no trailing semicolons
- Security-conscious DOM manipulation (createElement/textContent, not innerHTML)

**Prior decisions affecting this plan:**
- Reuse glassmorphic UI patterns from Phase 1 (visual consistency)
- Reuse multi-step form pattern from Phase 2 (progressive disclosure)
- In-memory Map storage for planning sessions (extends existing pattern)
- Hard gates enforce workflow discipline (users cannot skip design phase)
- Autosave with 30-second timer (established in Phase 2)

**Discovery recommendations:**
- Use 6-step progressive disclosure: (1) System Overview, (2) Component Breakdown, (3) Data & APIs, (4) Technology Stack, (5) Architectural Decisions, (6) Review
- Reuse validation patterns from Phase 2 (blur-based, character counters)
- Dynamic lists for components and architectural decisions
- Dropdown selects for common choices (architecture patterns, databases)
- Code editor textarea for schema definitions (monospace font)

**Existing planning session structure (from Phase 2):**
```typescript
interface PlanningSession {
  id: string;
  projectName: string;
  currentPhase: 'requirements' | 'design' | 'implementation';
  completedPhases: string[];
  phaseData: {
    requirements?: RequirementsFormData;  // Completed in Phase 2
    design?: any;  // Will store DesignFormData here
    implementation?: any;
  };
}
```

**PRD context from Phase 2:**
The design phase must build upon the PRD generated in Phase 2. User's generated PRD is available in `session.phaseData.requirements.generatedPRD` and should be referenced when planning technical design.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-step design form structure</name>
  <files>src/api/server.ts</files>
  <action>
Extend the `/planning` route's HTML template to add design form UI when currentPhase='design'.

Add a new section within the phase content area that displays when Design phase is active:

**6-Step Form Structure:**

**Step 1: System Overview**
- Field: Project Name (pre-filled from Phase 2, read-only display)
- Field: System Architecture Pattern (dropdown select)
  - Options: "Monolith", "Microservices", "Serverless", "Hybrid", "Other"
  - If "Other" selected, show text input for custom pattern
- Field: High-Level Architecture Description (textarea, 200 char min)
  - Placeholder: "Describe the overall system design and key architectural patterns"

**Step 2: Component Breakdown**
- Field: Components/Modules (dynamic list, min 1 required)
  - Each component has:
    - Name (text input, required)
    - Responsibility (text input, required, placeholder: "What does this component do?")
    - Dependencies (text input, optional, placeholder: "Comma-separated list of other components")
  - "+" button to add more components
  - "×" button to remove components (disabled if only 1 remains)

**Step 3: Data & APIs**
- Field: Database Schema (code textarea, 300 char min, monospace font)
  - Placeholder: "Describe your database schema, tables, and relationships"
- Field: API Contracts (code textarea, 200 char min, monospace font)
  - Placeholder: "Define key API endpoints, request/response formats"

**Step 4: Technology Stack**
- Field: Languages (dynamic list, min 1 required)
  - Examples pre-populated: ["TypeScript", "Python", "Go"]
- Field: Frameworks (dynamic list, min 1 required)
  - Examples: ["React", "Node.js", "FastAPI"]
- Field: Databases (dynamic list, min 1 required)
  - Dropdown select with options: "PostgreSQL", "MySQL", "MongoDB", "SQLite", "Redis", "Other"
- Field: Infrastructure (dynamic list, optional)
  - Examples: ["AWS", "Cloudflare", "Docker", "Kubernetes"]

**Step 5: Architectural Decisions (for ADRs)**
- Field: Key Architectural Decisions (dynamic list, min 1, max 10)
  - Each decision has:
    - Title (text input, required, placeholder: "e.g., Use PostgreSQL for primary database")
    - Context Description (textarea, required, 100 char min)
    - Decision Made (textarea, required, 100 char min)
    - Rationale (textarea, required, 100 char min)
  - Explanation text: "Each decision will generate an Architecture Decision Record (ADR)"
  - "+" button to add more decisions
  - "×" button to remove decisions (disabled if only 1 remains)

**Step 6: Review**
- Display summary of all inputs from Steps 1-5
- Read-only review of all fields
- "Back to Edit" button (returns to Step 5)
- "Generate Tech Spec & ADRs" button (submits form)

**UI Components:**
- Progress indicator showing "Step X of 6"
- "Back" button (disabled on Step 1)
- "Continue" button (disabled until required fields valid, changes to "Review" on Step 5, hidden on Step 6)
- Each step slides in/out with simple CSS transition
- Reuse glassmorphic card styling from Phase 1
- Form fields use existing `.input-group` styles
- Code textareas have monospace font (`font-family: 'Monaco', 'Menlo', monospace`)

**JavaScript State Management:**
- Track currentStep (1-6)
- Store all form values in memory object: `designFormData = { systemArchitecture, components, dataModels, ... }`
- Show/hide steps based on currentStep
- Validate required fields before enabling "Continue"
- On "Back", save current step data and go to previous step
- On "Continue", save current step data and go to next step
- On "Review" (Step 5), populate Step 6 summary and advance
- On "Generate Tech Spec & ADRs" (Step 6), prepare data for submission (handled in Plan 2)

**Validation Display:**
- Character counters below textareas (e.g., "45 / 200 characters")
- Red border + error message on invalid fields
- Error messages: "Architecture description must be at least 200 characters", "Please add at least one component", etc.
- Don't validate until user interacts with field (blur event)

**Special Handling for Step 6 (Review):**
- Display all inputs in read-only format using createElement/textContent (NEVER innerHTML)
- Group by step sections (System Overview, Components, Data & APIs, etc.)
- Show summary count: "X components, Y architectural decisions"
- "Back to Edit" button returns to Step 5 for final edits

Use safe DOM methods (createElement, textContent) - never innerHTML for user input.
  </action>
  <verify>
- Visit http://localhost:3000/planning after completing Phase 2 (requirements phase)
- Design phase shows 6-step form interface
- All 6 steps can be navigated with Back/Continue buttons
- Dropdowns for architecture patterns, databases work correctly
- Dynamic lists for components, tech stack, decisions support add/remove
- Character counters update as user types
- Required field validation prevents Continue until satisfied
- Step 6 displays read-only summary of all inputs
- Form styling matches glassmorphic design from Phase 1
  </verify>
  <done>Multi-step design form UI exists with 6 steps, validates required fields, displays character counts, uses glassmorphic styling</done>
</task>

<task type="auto">
  <name>Task 2: Implement form validation and state management</name>
  <files>src/api/server.ts</files>
  <action>
Add client-side JavaScript validation and form state management to the design form.

**Validation Rules (client-side):**
```javascript
const designValidationRules = {
  systemArchitecture: { required: true, minLength: 1 },
  architectureDescription: { min: 200, max: 2000, required: true },
  components: { minItems: 1, maxItems: 50, required: true },
  // Each component:
  componentName: { min: 2, max: 100, required: true },
  componentResponsibility: { min: 10, max: 500, required: true },
  databaseSchema: { min: 300, max: 5000, required: true },
  apiContracts: { min: 200, max: 5000, required: true },
  languages: { minItems: 1, maxItems: 10, required: true },
  frameworks: { minItems: 1, maxItems: 10, required: true },
  databases: { minItems: 1, maxItems: 5, required: true },
  infrastructure: { minItems: 0, maxItems: 10, required: false },
  architecturalDecisions: { minItems: 1, maxItems: 10, required: true },
  // Each decision:
  decisionTitle: { min: 5, max: 150, required: true },
  decisionContext: { min: 100, max: 1000, required: true },
  decisionMade: { min: 100, max: 1000, required: true },
  decisionRationale: { min: 100, max: 1000, required: true }
};
```

**Validation Functions:**
- `validateDesignField(fieldName, value)` - Returns `{ valid: boolean, error?: string }`
- `validateDesignStep(stepNumber)` - Validates all fields in current step
- `updateCharCount(textarea, counter)` - Updates character count display (reuse from Phase 2)
- `showFieldError(field, message)` - Displays inline error message (reuse from Phase 2)
- `clearFieldError(field)` - Removes error message (reuse from Phase 2)

**Event Handlers:**
- On `blur` for text inputs/textareas: Validate field, show error if invalid
- On `input` for textareas: Update character counter
- On `change` for dropdowns: Validate selection, show "Other" input if needed
- On "Add Component/Decision/Tech" button click: Add new input to list
- On "Remove" button click: Remove input from list (minimum enforced for required lists)
- On "Continue" button click: Validate current step, proceed if valid
- On "Back" button click: Save data, go to previous step (no validation)
- On "Review" button click (Step 5): Populate Step 6 summary, advance

**State Persistence:**
Store form data in global JavaScript object:
```javascript
let designFormData = {
  systemArchitecture: '',
  architectureDescription: '',
  components: [{ name: '', responsibility: '', dependencies: '' }],
  databaseSchema: '',
  apiContracts: '',
  technologyStack: {
    languages: [''],
    frameworks: [''],
    databases: [''],
    infrastructure: []
  },
  architecturalDecisions: [{
    title: '',
    contextDescription: '',
    decisionMade: '',
    rationale: ''
  }]
};
```

Update this object as user types/changes fields. This will be sent to API in Plan 2.

**Dynamic List Management:**
- Components list: Each item is an object `{ name, responsibility, dependencies }`
  - Render input fields from `designFormData.components` array
  - "+" button: `designFormData.components.push({ name: '', responsibility: '', dependencies: '' })`, re-render
  - "×" button: `designFormData.components.splice(index, 1)`, re-render
  - Don't allow removing last component (disable "×" button)

- Architectural Decisions list: Each item is `{ title, contextDescription, decisionMade, rationale }`
  - Render 4 fields per decision (title, context, decision, rationale)
  - "+" button: `designFormData.architecturalDecisions.push({...})`, re-render
  - "×" button: `designFormData.architecturalDecisions.splice(index, 1)`, re-render
  - Don't allow removing last decision (disable "×" button)

- Tech Stack lists (languages, frameworks, databases, infrastructure):
  - Simple string arrays, similar to Phase 2 features list
  - "+" button adds empty string, re-render
  - "×" button removes item, re-render

**Step 6 Review Summary:**
Generate read-only summary from `designFormData` using ONLY createElement and textContent (NEVER innerHTML):
```javascript
function populateReviewSummary() {
  const summary = document.getElementById('review-summary');
  // Clear existing content
  while (summary.firstChild) {
    summary.removeChild(summary.firstChild);
  }

  // System Overview section
  const overviewSection = document.createElement('div');
  overviewSection.className = 'review-section';

  const overviewTitle = document.createElement('h3');
  overviewTitle.textContent = 'System Overview';
  overviewSection.appendChild(overviewTitle);

  const archPattern = document.createElement('p');
  archPattern.textContent = `Architecture Pattern: ${designFormData.systemArchitecture}`;
  overviewSection.appendChild(archPattern);

  const archDesc = document.createElement('p');
  archDesc.textContent = designFormData.architectureDescription;
  overviewSection.appendChild(archDesc);

  summary.appendChild(overviewSection);

  // Components section (iterate using createElement/textContent)
  // Data & APIs section (iterate using createElement/textContent)
  // Tech Stack section (iterate using createElement/textContent)
  // Architectural Decisions section (iterate using createElement/textContent)
}
```

**UI Feedback:**
- Invalid field: Red border (`border: 2px solid #ef4444`)
- Valid field: No visual change (default state)
- Error message: Red text below field
- Character counter: Gray text when under limit, red when over limit
- "Continue" button: Disabled (opacity 0.5, cursor not-allowed) until step valid
- Code textareas: Monospace font for better readability

No server calls yet - all validation is client-side. Server-side validation added in Plan 2.
  </action>
  <verify>
- Fill in Step 1 with invalid architecture description (< 200 chars): Continue button stays disabled
- Fill in valid architecture description: Continue button enables
- Navigate to Step 2, try to remove the only component: "×" button is disabled
- Add 3 components, remove 1: Works correctly
- Step 3 code textareas display in monospace font
- Step 4 dynamic lists (languages, frameworks) support add/remove
- Step 5 architectural decisions support add/remove (4 fields per decision)
- Character counter turns red when exceeding limit
- Step 6 displays read-only summary of all inputs grouped by section
- All validation rules enforce correctly
  </verify>
  <done>Client-side validation works for all fields, dynamic lists support add/remove with nested objects, character counters update, Step 6 review summary displays correctly using safe DOM methods</done>
</task>

<task type="auto">
  <name>Task 3: Add form autosave to planning session</name>
  <files>src/api/server.ts, src/sdlc/types.ts</files>
  <action>
Implement autosave functionality that stores design form data in the planning session.

**Backend Changes:**

1. **Update PlanningSession type in src/sdlc/types.ts:**
```typescript
export interface ComponentDefinition {
  name: string;
  responsibility: string;
  dependencies?: string;
}

export interface TechStack {
  languages: string[];
  frameworks: string[];
  databases: string[];
  infrastructure: string[];
}

export interface ArchitecturalDecision {
  title: string;
  contextDescription: string;
  decisionMade: string;
  rationale: string;
}

export interface DesignFormData {
  systemArchitecture: string; // Selected pattern or custom
  architectureDescription: string;
  components: ComponentDefinition[];
  databaseSchema: string;
  apiContracts: string;
  technologyStack: TechStack;
  architecturalDecisions: ArchitecturalDecision[];
  lastSaved?: Date;
}

// Update phaseData in PlanningSession:
phaseData: {
  requirements?: RequirementsFormData;
  design?: DesignFormData;  // Add this
  implementation?: any;
};
```

2. **Add autosave API route in src/api/server.ts:**
```typescript
POST /api/planning/design/autosave

Input schema (Zod):
const ComponentDefinitionSchema = z.object({
  name: z.string().min(2).max(100),
  responsibility: z.string().min(10).max(500),
  dependencies: z.string().max(500).optional()
});

const TechStackSchema = z.object({
  languages: z.array(z.string()).min(1).max(10),
  frameworks: z.array(z.string()).min(1).max(10),
  databases: z.array(z.string()).min(1).max(5),
  infrastructure: z.array(z.string()).max(10).default([])
});

const ArchitecturalDecisionSchema = z.object({
  title: z.string().min(5).max(150),
  contextDescription: z.string().min(100).max(1000),
  decisionMade: z.string().min(100).max(1000),
  rationale: z.string().min(100).max(1000)
});

const AutosaveDesignSchema = z.object({
  systemArchitecture: z.string().min(1),
  architectureDescription: z.string().min(200).max(2000),
  components: z.array(ComponentDefinitionSchema).min(1).max(50),
  databaseSchema: z.string().min(300).max(5000),
  apiContracts: z.string().min(200).max(5000),
  technologyStack: TechStackSchema,
  architecturalDecisions: z.array(ArchitecturalDecisionSchema).min(1).max(10)
});

Logic:
- Get current planning session (same pattern as /api/planning/requirements/autosave)
- Validate input with Zod schema
- Update session.phaseData.design with form data
- Set session.phaseData.design.lastSaved = new Date()
- Return { success: true, data: { lastSaved: timestamp } }
```

**Frontend Changes (in /planning route's JavaScript):**

Add autosave functionality (reuse exact pattern from Phase 2):
```javascript
// Autosave every 30 seconds if form has changes
let autosaveTimerDesign;
let designFormDirty = false;

function markDesignFormDirty() {
  designFormDirty = true;
  if (!autosaveTimerDesign) {
    autosaveTimerDesign = setTimeout(autosaveDesign, 30000); // 30 seconds
  }
}

async function autosaveDesign() {
  if (!designFormDirty) return;

  try {
    const response = await fetch('/api/planning/design/autosave', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(designFormData)
    });

    const result = await response.json();
    if (result.success) {
      designFormDirty = false;
      showAutosaveIndicator('Saved');
    }
  } catch (error) {
    console.error('Design autosave failed:', error);
  }

  autosaveTimerDesign = null;
}

// Attach markDesignFormDirty to all input events
document.querySelectorAll('.design-form input, .design-form textarea, .design-form select').forEach(el => {
  el.addEventListener('input', markDesignFormDirty);
  el.addEventListener('change', markDesignFormDirty);
});
```

**Load saved data on page load:**
```javascript
async function loadSavedDesign() {
  const state = await fetch('/api/planning/state').then(r => r.json());
  if (state.success && state.data.phaseData?.design) {
    designFormData = state.data.phaseData.design;
    populateDesignFormFromData();
  }
}

// Call on page load (when currentPhase === 'design')
loadSavedDesign();
```

**Autosave Trigger Events:**
- User types in any field (debounced to 30 seconds)
- User clicks "Back" or "Continue" (immediate save before navigation)
- User leaves page (beforeunload event - best effort)

**UI Indicator:**
- Reuse same "Saving.../ Saved ✓" indicator from Phase 2
- Small message in top-right corner
- Fades out after 2 seconds

This ensures users never lose their design work even if they refresh the browser or close the tab.
  </action>
  <verify>
- Fill in Step 1, wait 30 seconds: Autosave indicator shows "Saved ✓"
- Refresh browser: Form data persists, pre-fills from saved state
- Fill in Steps 1-5, close browser, reopen: All data still present including components array
- Check /api/planning/state: phaseData.design contains form inputs
- Verify complex nested structures (components, architecturalDecisions) persist correctly
- TypeScript compiles without errors
  </verify>
  <done>Autosave API route exists, client-side autosave triggers every 30 seconds, saved data persists across page refreshes including nested objects, UI shows save indicator</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] `npm run dev` starts server without crashes
- [ ] Visit /planning after completing Phase 2 (requirements phase)
- [ ] Design phase shows 6-step form with all fields
- [ ] Form validation prevents Continue until required fields valid
- [ ] Dynamic lists (components, tech stack, decisions) support add/remove
- [ ] Character counters update in real-time
- [ ] Dropdowns for architecture patterns, databases work correctly
- [ ] Code textareas display in monospace font
- [ ] Step 6 displays read-only summary of all inputs using safe DOM methods
- [ ] Autosave triggers after 30 seconds of inactivity
- [ ] Refreshing browser preserves form data including nested objects
- [ ] No TypeScript errors or warnings
- [ ] UI matches glassmorphic aesthetic from Phase 1
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Multi-step design form operational at /planning
- Form validation works client-side with visual feedback
- Autosave preserves user input across sessions
- Character counters and dynamic lists function correctly
- Nested object structures (components, decisions) handle correctly
- Step 6 review summary displays all inputs using createElement/textContent only
- Styling consistent with existing dashboard
- TypeScript strict mode passes
- No runtime errors in browser console
</success_criteria>

<output>
After completion, create `.planning/phases/03-design-phase-ui/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Design Form UI Summary

**Multi-step design form with component breakdown and architectural decision inputs - ready for Claude integration.**

## Accomplishments

- Created 6-step progressive disclosure design form
- Implemented client-side validation with visual feedback
- Added autosave functionality preserving user inputs
- Built dynamic list UI for components, tech stack, architectural decisions
- Integrated character counters for textarea fields
- Code textareas with monospace font for schema definitions
- Extended planning session types for design data
- Step 6 review summary displays all inputs using safe DOM methods

## Files Created/Modified

- `src/api/server.ts` - Added design form HTML template and autosave API route
- `src/sdlc/types.ts` - Added DesignFormData, ComponentDefinition, TechStack, ArchitecturalDecision interfaces

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 03-02-PLAN.md - Claude API integration for Technical Specification and ADR generation
</output>
